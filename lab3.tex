\documentclass[bachelor, och, labwork]{shiza}

\usepackage{subfigure}
\usepackage{tikz,pgfplots}
\pgfplotsset{compat=1.5}
\usepackage{float}

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{35.5pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\titleformat{\paragraph}[block]
{\hspace{1.25cm}\normalfont}
{\theparagraph}{1ex}{}
\titlespacing{\paragraph}
{0cm}{2ex plus 1ex minus .2ex}{.4ex plus.2ex}

% --------------------------------------------------------------------------%


\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{tempora}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}

\usepackage[colorlinks=true]{hyperref}
\usepackage{url}

\usepackage{underscore}
\usepackage{setspace}
\usepackage{indentfirst} 
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{minted}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newcommand{\specialcell}[2][c]{%
\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\renewcommand\theFancyVerbLine{\small\arabic{FancyVerbLine}}


\begin{document}

% \chair{Кафедра теоретических основ компьютерной безопасности и криптографии}

\title{Умножение разреженных полиномов}

\course{3}

\group{331}

\department{факультета КНиИТ}

\napravlenie{10.05.01 "--- Компьютерная безопасность}

\author{Никитина Арсения Владимировича}

\satitle{доцент, к.т.о.к.б.и.к}

\saname{А. Н. Гамова}

\date{2022}

\maketitle

%-------------------------------------------------------------------------------
\tableofcontents

\intro
В данной работе будут рассмотрены принципы алгоритмов вычисления умножения 
разреженных полинонов, оценки работы алгоритмов в наилучшем и наихудшем случаях,
а также программная реализация алгоритмов. 

Арифметичесике операции, такие как умножение, над целыми числами и полиномами
лучше изучать в совокупности, так как многие алгоритмы, работающие с целыми 
числами по существую совпадают с алгоритмами, работающими с полиномами от одной
переменной. Это верно не только для таких операций, как умножение и деление, но
такоэе и для более сложно осписываемых операций. Например, нахождение вычета
целого числа по модулю, задаваемому другим целым числом.


\section{Определение полинома}

Если $i$ - неотрицательное целое число то размер($i$)=$\log i + 1$. Если $p(x)$
- полином, то размер($p$)=$CT(p) + 1$, где $CT(p)$ - степень полинома $p$, то
есть наибольшая степень переменной $x$ с нулевым коэффициентом.

Над целыми числами и полиномами моно выполнять приближенное деление. Если 
$a ~\text{и}~ b$ - два целых числа и $b \not= 0$, то найдется единственная пара
целых чисел $q ~\text{и}~ r$, для которых








\begin{center}Алгоритм функции $partition$\end{center}

Итак, выберем наугад любой элемент входного массива данных и назовем его $x$.
Затем будем просматривать слева направа весь массив до тех пор, пока не
обнаружим первый элемент, больший выбранного. Далее будем просматривать весь
массив справа, пока не встретим первый элемент, меньший выбранного.
Затем поменяем местами найденные элементы и продолжим процесс просмотра и обмена,
пока оба просмотра не встретятся в середине массива. В результате 
проделанных операций, массив окажется разбитым на две части: с ключами, меньшими
или равными заданному числу и с ключами, большими этого числа.
В программной реализации же, включение одной из частей является не строгим и 
выбранный элемент $x$ является барьером между частями.

\begin{center}Алгоритм функции $sort$\end{center}

Далее нужно применить описанный выше алгоритм к получившимся двум частям, затем 
к четырем и так далее. Поэтому требуется рекурсивный вызов некоторой функции 
$sort$.

Также у обычного метода сортировки выбором присутствует множество оптимизаций. 
Например, оптимизация выбора разделяющего. В данной реализации происходит выбор 
медианного элемента из массива, поэтому скорость работы алгоритма в среднем 
улучшается.

Также метод можно реализовать итеративно, но для этого требуются лишние затраты
памяти.


\section{Программная реализация алгоритма}

\inputminted[linenos,breaklines=true, fontsize=\small, style=bw]{python}{qs.py}

\section{Оценка работы алгоритма}

Для исследования производительности быстрой сортировки сначала необходимо
разобраться, как идет процесс разделения. Выбрав некоторое граничное значение
$x$, происходит обход по всему массиву, а, значит, при этом выполняется точно
$n$ сравнений. Число же обменов можно определить из следующих
вероятностных соображений.

При заданной границе значений $x$ ожидаемое число операций обмена равно числу 
элементов в левой части разделяемой последовательности, то есть $n-1$,
умноженному на вероятность того, что при обмене каждый такой элемент перед этим
находился в правой части. Вероятность этого равна $(n-(x-1))/n$. Поэтому 
ожидаемое число обменов есть среднее этих ожидаемых значений для возможных
границ, то есть получаем: $((n-1)/n)/6$.

Пусть всегда удается выбрать в качестве границы медиану, в этом случае каждый 
процесс разделений ресщеплет массив на две половины и для сортировки требуется
всего $\log n$ проходов. В результате общее число сравнений равно $n*\log n$,
а общее число обменов - $n * \log (n)/6$.

Если же выбор разделяющего элемента не всегда идеален, то сложность алгоритма
отличается на коэффициент $2* \ln 2$.

Также стоит сказать, что алгоритм имеет преимущетсво перед другими
усовершенствованными, что для обработки небольших частей массива в него можно 
включить какой-либо из методом прямой сортировки.

Наихудший же случай работы алгоритма достигается, когда для сравнения выбирается
наибольший элемент из значений, сосоящих в части. Тогда на каждом этапе сегмент 
из $n$ элементов будет расщепляться на левую часть, состоящую из $n-1$ элементов,
и на правую часть, состоящую из одного элемента (выбранного). Тогда в результате
требуется $n$ разделений и наихудшая произовительность метода будет порядка 
$n^2$. 

Исследования Сама Хоара показывают, что наилучшая производительность алгоритма
достигается при случайном выборе разделяющего элемента.

\conclusion

Итак, в данной работе был рассмотрен алгоритм сортировки с помощью разделения.
Произведена оценка его работы в худшем и в лучшем случае. В худшем случае
ассимптотика работы алгоритма составляет $O(n^2)$ операций, 
в лучшем - $O(n*\log n)$.

Наиболее оптимальмальная работа алгоритма достигается при случайном выборе
разделяющего элемента: в таком случае вероятность того, что за один проход
алгоритма будет совершено операций обмена менее $\log n$ при 
$\lim\limits_{n\rightarrow\infty }$ стремится к нулю.
\end{document}