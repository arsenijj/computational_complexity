\documentclass[bachelor, och, labwork]{shiza}

\usepackage{subfigure}
\usepackage{tikz,pgfplots}
\pgfplotsset{compat=1.5}
\usepackage{float}

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{35.5pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\titleformat{\paragraph}[block]
{\hspace{1.25cm}\normalfont}
{\theparagraph}{1ex}{}
\titlespacing{\paragraph}
{0cm}{2ex plus 1ex minus .2ex}{.4ex plus.2ex}

% --------------------------------------------------------------------------%


\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{tempora}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}

\usepackage[colorlinks=true]{hyperref}
\usepackage{url}

\usepackage{underscore}
\usepackage{setspace}
\usepackage{indentfirst} 
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{minted}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newcommand{\specialcell}[2][c]{%
\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\renewcommand\theFancyVerbLine{\small\arabic{FancyVerbLine}}


\begin{document}

% \chair{Кафедра теоретических основ компьютерной безопасности и криптографии}

\title{Сортировка с помощью разделения}

\course{3}

\group{331}

\department{факультета КНиИТ}

\napravlenie{10.05.01 "--- Компьютерная безопасность}

\author{Никитина Арсения Владимировича}

\satitle{доцент, к.т.о.к.б.и.к}

\saname{А. Н. Гамова}

\date{2022}

\maketitle

%-------------------------------------------------------------------------------
\tableofcontents

\intro
В данной работе будут рассмотрены принципы работы сортировки с помощью 
разделения, также известной под названием QuickSort, оценки работы сортировки в 
наилучшем и наихудшем случаях, а также ее программная реализация.
Сортировку с помощью разделения также называют быстрой сортировкой, так как она
является существенно улучшенным вариантом алгоритма сортировки с помощью 
прямого обмена (его варианты известны как «Пузырьковая сортировка» и «Шейкерная 
сортировка»), известного в том числе своей низкой эффективностью. Принципиальное 
отличие состоит в том, что в первую очередь производятся перестановки на 
наибольшем возможном расстоянии и после каждого прохода элементы делятся на две 
независимые группы.

\section{Принципы работы сортировки разделением}

Для достижения наибольшей эффективности сначала лучше производить перестановки
на большие расстояния. Предположим, что у нас есть $n$ элементов, расположенных
в обратно отсортированном порядке. Их можно отсортировать за $n/2$ операций,
если заранее знать, что порядок именно таков.

\begin{center}Алгоритм функции $partition$\end{center}

Итак, выберем наугад любой элемент входного массива данных и назовем его $x$.
Затем будем просматривать слева направа весь массив до тех пор, пока не
обнаружим первый элемент, больший выбранного. Далее будем просматривать весь
массив справа, пока не встретим первый элемент, меньший выбранного.
Затем поменяем местами найденные элементы и продолжим процесс просмотра и обмена,
пока оба просмотра не встретятся в середине массива. В результате 
проделанных операций, массив окажется разбитым на две части: с ключами, меньшими
или равными заданному числу и с ключами, большими этого числа.
В программной реализации же, включение одной из частей является не строгим и 
выбранный элемент $x$ является барьером между частями.

\begin{center}Алгоритм функции $sort$\end{center}

Далее нужно применить описанный выше алгоритм к получившимся двум частям, затем 
к четырем и так далее. Поэтому требуется рекурсивный вызов некоторой функции 
$sort$.

Также у обычного метода сортировки выбором присутствует множество оптимизаций. 
Например, оптимизация выбора разделяющего. В данной реализации происходит выбор 
медианного элемента из массива, поэтому скорость работы алгоритма в среднем 
улучшается.

Также метод можно реализовать итеративно, но для этого требуются лишние затраты
памяти.


\section{Программная реализация алгоритма}

\inputminted[linenos,breaklines=true, fontsize=\small, style=bw]{python}{qs.py}

\section{Оценка работы алгоритма}

Для исследования производительности быстрой сортировки сначала необходимо
разобраться, как идет процесс разделения. Выбрав некоторое граничное значение
$x$, происходит обход по всему массиву, а, значит, при этом выполняется точно
$n$ сравнений. Число же обменов можно определить из следующих
вероятностных соображений.

При заданной границе значений $x$ ожидаемое число операций обмена равно числу 
элементов в левой части разделяемой последовательности, то есть $n-1$,
умноженному на вероятность того, что при обмене каждый такой элемент перед этим
находился в правой части. Вероятность этого равна $(n-(x-1))/n$. Поэтому 
ожидаемое число обменов есть среднее этих ожидаемых значений для возможных
границ, то есть получаем: $((n-1)/n)/6$.

Пусть всегда удается выбрать в качестве границы медиану, в этом случае каждый 
процесс разделений ресщеплет массив на две половины и для сортировки требуется
всего $\log n$ проходов. В результате общее число сравнений равно $n*\log n$,
а общее число обменов - $n * \log (n)/6$.

Если же выбор разделяющего элемента не всегда идеален, то сложность алгоритма
отличается на коэффициент $2* \ln 2$.

Также стоит сказать, что алгоритм имеет преимущетсво перед другими
усовершенствованными, что для обработки небольших частей массива в него можно 
включить какой-либо из методом прямой сортировки.

Наихудший же случай работы алгоритма достигается, когда для сравнения выбирается
наибольший элемент из значений, сосоящих в части. Тогда на каждом этапе сегмент 
из $n$ элементов будет расщепляться на левую часть, состоящую из $n-1$ элементов,
и на правую часть, состоящую из одного элемента (выбранного). Тогда в результате
требуется $n$ разделений и наихудшая произовительность метода будет порядка 
$n^2$. 

Исследования Сама Хоара показывают, что наилучшая производительность алгоритма
достигается при случайном выборе разделяющего элемента.

\conclusion

Итак, в данной работе был рассмотрен алгоритм сортировки с помощью разделения.
Произведена оценка его работы в худшем и в лучшем случае. В худшем случае
ассимптотика работы алгоритма составляет $O(n^2)$ операций, 
в лучшем - $O(n*\log n)$.

Наиболее оптимальмальная работа алгоритма достигается при случайном выборе
разделяющего элемента: в таком случае вероятность того, что за один проход
алгоритма будет совершено операций обмена менее $\log n$ при 
$\lim\limits_{n\rightarrow\infty }$ стремится к нулю.
\end{document}